// Code generated by github.com/ngicks/go-f-helper/aferofs/cmd/implwrapper. DO NOT EDIT.
package aferofs

import (
	"io/fs"
	"time"

	"github.com/spf13/afero"
)

func (recv *ObservableFs) Create(name string) (f afero.File, err error) {
	if checkErr := recv.beforeEach("Create", name); checkErr != nil {
		err = checkErr
		return
	}
	f, err = recv.inner.Create(name)
	if checkErr := recv.afterEach("Create", f, err); checkErr != nil {
		err = checkErr
		return
	}
	f = recv.modifyFile("Create", f)
	return
}

func (recv *ObservableFs) Mkdir(name string, perm fs.FileMode) (err error) {
	if checkErr := recv.beforeEach("Mkdir", name, perm); checkErr != nil {
		err = checkErr
		return
	}
	err = recv.inner.Mkdir(name, perm)
	if checkErr := recv.afterEach("Mkdir", err); checkErr != nil {
		err = checkErr
		return
	}
	return
}

func (recv *ObservableFs) MkdirAll(path string, perm fs.FileMode) (err error) {
	if checkErr := recv.beforeEach("MkdirAll", path, perm); checkErr != nil {
		err = checkErr
		return
	}
	err = recv.inner.MkdirAll(path, perm)
	if checkErr := recv.afterEach("MkdirAll", err); checkErr != nil {
		err = checkErr
		return
	}
	return
}

func (recv *ObservableFs) Open(name string) (f afero.File, err error) {
	if checkErr := recv.beforeEach("Open", name); checkErr != nil {
		err = checkErr
		return
	}
	f, err = recv.inner.Open(name)
	if checkErr := recv.afterEach("Open", f, err); checkErr != nil {
		err = checkErr
		return
	}
	f = recv.modifyFile("Open", f)
	return
}

func (recv *ObservableFs) OpenFile(name string, flag int, perm fs.FileMode) (f afero.File, err error) {
	if checkErr := recv.beforeEach("OpenFile", name, flag, perm); checkErr != nil {
		err = checkErr
		return
	}
	f, err = recv.inner.OpenFile(name, flag, perm)
	if checkErr := recv.afterEach("OpenFile", f, err); checkErr != nil {
		err = checkErr
		return
	}
	f = recv.modifyFile("OpenFile", f)
	return
}

func (recv *ObservableFs) Remove(name string) (err error) {
	if checkErr := recv.beforeEach("Remove", name); checkErr != nil {
		err = checkErr
		return
	}
	err = recv.inner.Remove(name)
	if checkErr := recv.afterEach("Remove", err); checkErr != nil {
		err = checkErr
		return
	}
	return
}

func (recv *ObservableFs) RemoveAll(path string) (err error) {
	if checkErr := recv.beforeEach("RemoveAll", path); checkErr != nil {
		err = checkErr
		return
	}
	err = recv.inner.RemoveAll(path)
	if checkErr := recv.afterEach("RemoveAll", err); checkErr != nil {
		err = checkErr
		return
	}
	return
}

func (recv *ObservableFs) Rename(oldname string, newname string) (err error) {
	if checkErr := recv.beforeEach("Rename", oldname, newname); checkErr != nil {
		err = checkErr
		return
	}
	err = recv.inner.Rename(oldname, newname)
	if checkErr := recv.afterEach("Rename", err); checkErr != nil {
		err = checkErr
		return
	}
	return
}

func (recv *ObservableFs) Stat(name string) (fi fs.FileInfo, err error) {
	if checkErr := recv.beforeEach("Stat", name); checkErr != nil {
		err = checkErr
		return
	}
	fi, err = recv.inner.Stat(name)
	if checkErr := recv.afterEach("Stat", fi, err); checkErr != nil {
		err = checkErr
		return
	}
	return
}

func (recv *ObservableFs) Name() (name string) {
	_ = recv.beforeEach("Name")
	name = recv.inner.Name()
	_ = recv.afterEach("Name", name)
	return
}

func (recv *ObservableFs) Chmod(name string, mode fs.FileMode) (err error) {
	if checkErr := recv.beforeEach("Chmod", name, mode); checkErr != nil {
		err = checkErr
		return
	}
	err = recv.inner.Chmod(name, mode)
	if checkErr := recv.afterEach("Chmod", err); checkErr != nil {
		err = checkErr
		return
	}
	return
}

func (recv *ObservableFs) Chown(name string, uid int, gid int) (err error) {
	if checkErr := recv.beforeEach("Chown", name, uid, gid); checkErr != nil {
		err = checkErr
		return
	}
	err = recv.inner.Chown(name, uid, gid)
	if checkErr := recv.afterEach("Chown", err); checkErr != nil {
		err = checkErr
		return
	}
	return
}

func (recv *ObservableFs) Chtimes(name string, atime time.Time, mtime time.Time) (err error) {
	if checkErr := recv.beforeEach("Chtimes", name, atime, mtime); checkErr != nil {
		err = checkErr
		return
	}
	err = recv.inner.Chtimes(name, atime, mtime)
	if checkErr := recv.afterEach("Chtimes", err); checkErr != nil {
		err = checkErr
		return
	}
	return
}
